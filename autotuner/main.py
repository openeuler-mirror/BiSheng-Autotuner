#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Main functions for Autotuner's command-line interface
Copyright (C) 2017-2020, Huawei Technologies Co., Ltd. All rights reserved.
"""
import argparse
import glob
import os
import imp
import sys
from collections import OrderedDict
from importlib import import_module

from configparser import Error as ConfigParserError
from configparser import ConfigParser

import opentuner
import autotuner.tuners.tunerbase as tunerbase
import autotuner.utils as utils
from autotuner.tuners.simple_tuner import SimpleTuner
from autotuner.iomanager import EmptySearchSpaceError
from autotuner.iomanager import argument_parser
from autotuner.iomanagerutils import create_io_manager


def _add_common_tuner_arguments(parser):
    parser.add_argument('config_file', nargs='?',
                        help='The tuning config file.')
    parser.add_argument('--plugin-dir', metavar='DIR',
                        help='specify the dir to load '
                             'customized tuner scripts')
    parser.add_argument('-tr', '--tuner',
                        type=str,
                        help="Select which tuner to use")
    parser.add_argument('-lr', '--list-tuners',
                        action="store_true", help="List all available tuners")
    parser.add_argument('--add-llvm-inputs', nargs='+',
                        help="add existing llvm configuration input files as "
                             "constants in addition to the llvm configurations"
                             " generated in each iteration of the tuning run")


def _add_common_parse_arguments(parser):
    parser.add_argument('-nf', '--name-filter', nargs='+', metavar='Name',
                        default=[],
                        help='to filter code regions by names when generating '
                             'search space')
    parser.add_argument('--func-name-filter', nargs='+', metavar='Name',
                        default=[],
                        help='to filter code regions by function names when '
                             'generating search space')
    parser.add_argument('--file-name-filter', nargs='+', metavar='Name',
                        default=[],
                        help='to filter code regions by file names when '
                             'generating search space')
    parser.add_argument('--hot-func-file', nargs='+', metavar='Name',
                        default=[],
                        help=argparse.SUPPRESS)
    parser.add_argument('--hot-func-number', metavar='N', type=int, default=10,
                        help=argparse.SUPPRESS)
    parser.add_argument('-scf', '--search-config-file',
                        help='The Search space config file')


def get_args():
    # create the top-level parser
    parser = argparse.ArgumentParser(prog='auto-tuner')
    subparsers = parser.add_subparsers(help='commands help', dest='command')
    subparsers.required = True

    # create the the parser for the "run" command
    argparsers = opentuner.argparsers()
    argparsers.append(tunerbase.argument_parser)
    argparsers.append(argument_parser)

    run_parser = subparsers.add_parser('run',
                                       parents=argparsers,
                                       help='Run the tuner')
    _add_common_tuner_arguments(run_parser)
    run_parser.add_argument('-ss', '--search_space',
                            help='The search space file.')
    run_parser.add_argument('--enable-final-compile', action='store_true',
                            default=False,
                            help='perform final compilation with optimal '
                                 'config at the end of tuning')

    # create the parser for the "merge" command
    merge_parser = subparsers.add_parser(
        'merge', parents=[argument_parser],
        help='Merge LLVM configuration input files')
    merge_parser.add_argument(
        'input_file', nargs='+',
        help='LLVM configuration input files generated by LLVM')
    merge_parser.add_argument(
        '-o', '--output', metavar='FILE', help='output file')

    # create the parser for the "divide" command
    divide_parser = subparsers.add_parser('divide', parents=[argument_parser],
                                          help='Divide LLVM configuration '
                                               'input file into multiple files'
                                               ' based on file_name')
    divide_parser.add_argument(
        'input_file', help='LLVM configuration input file generated by LLVM')
    divide_parser.add_argument(
        '-o', '--output_dir', metavar='DIR', help='output dir', default='./')

    # create the parser for the "parse" command
    gsc_parser = subparsers.add_parser('parse', parents=[
        argument_parser], help='Parse the tuning'
                               ' opportunity files and generate '
                               'search space')

    _add_common_parse_arguments(gsc_parser)
    gsc_parser.add_argument('opp_file', nargs='+',
                            help="Opportunity files generated by LLVM")
    gsc_parser.add_argument('-o', '--output', metavar='FILE',
                            help='output file')
    gsc_parser.add_argument('-tf', '--type-filter', nargs='+', default=[],
                            help='to filter code regions by types when'
                                 ' generating search space',
                            choices=['machine_basic_block', 'loop', 'function',
                                     'module'])

    # create the the parser for the "auto_run" command
    auto_run_parser = subparsers.add_parser('auto_run',
                                            parents=argparsers,
                                            help='(recommended) auto-generate '
                                                 'the search space and run the'
                                                 ' auto-phase-based tuning '
                                                 '(the default order of stages'
                                                 ' is module -> function '
                                                 '-> loop)')

    auto_run_parser.add_argument('--stage-order', nargs='+', metavar='stage',
                                 default=["module", "function", "loop"],
                                 help='specify stage order of auto_run. '
                                      'each stage is a code region type',
                                 choices=['machine_basic_block', 'function',
                                          'loop', 'module'])

    _add_common_parse_arguments(auto_run_parser)
    _add_common_tuner_arguments(auto_run_parser)

    args = parser.parse_args()

    return args


def _parse_common_options(args):
    if args.list_tuners:
        print("Available tuners: " +
              str(tunerbase.get_available_tuners(args.plugin_dir)))
        sys.exit(0)

    if args.list_techniques:
        techniques, _ = opentuner.search.technique.all_techniques()
        for technique in techniques:
            print(technique.name)
        sys.exit(0)

    if not args.config_file:
        # config file is required
        print("Auto-tuner run: error: config file is required")
        sys.exit(1)

    if args.command == "run" and not args.search_space:
        # search space is required for run command
        print("Auto-tuner run: error: argument -ss/--search_space is required")
        sys.exit(1)

    if args.tuner:
        try:
            if args.plugin_dir:
                if not os.path.isdir(args.plugin_dir):
                    raise IOError("Error: " + args.plugin_dir + " not found")
                module_file = os.path.join(args.plugin_dir, args.tuner + ".py")
                if not os.path.isfile(module_file):
                    raise IOError("Error: " + module_file + " not found")
                module = imp.load_source(args.tuner, module_file)
            else:
                module = import_module("autotuner.tuners." + args.tuner)
            tuner = getattr(module, 'Tuner')
        except ImportError as error:
            print(error)
            print("Please select a valid tuner name.")
            print("Available tuners: " +
                  str(tunerbase.get_available_tuners(args.plugin_dir)))
            sys.exit(-1)
    else:
        tuner = SimpleTuner

    if args.output:
        if not os.path.isdir(args.output):
            try:
                os.mkdir(args.output)
            except OSError as error:
                raise error

    # parse ini config file
    if not os.path.isfile(args.config_file):
        raise IOError("Error: config file not found")

    # check file permissions
    utils.check_file_permissions(args.config_file)

    config = ConfigParser()
    config.optionxform = str
    config["DEFAULT"]["ConfigFilePath"] = os.path.abspath(
        os.path.dirname(args.config_file))
    config.read(args.config_file)
    # set up system environment
    if config.has_section("Environment Setting"):
        _setup_env(config["Environment Setting"])
    return tuner, config


def _setup_env(environment_section):
    for (key, value) in list(environment_section.items()):
        path_list = [os.path.expanduser(path.strip())
                     for path in value.split(",")]
        # if the environment variable exists, prepend to the existing one
        if key in os.environ:
            # prepend to the existing one
            os.environ[key] = os.pathsep.join(path_list) \
                + os.pathsep + os.environ[key]
        else:
            # create the environment variable
            os.environ[key] = os.pathsep.join(path_list)


def _clean_opp(opp_dir):
    files = glob.glob(opp_dir + "/*")
    for ele in files:
        if os.path.isfile(ele):
            os.remove(ele)


def divide_main(args):
    """
    main program for divide command
    """
    iomanager = create_io_manager(args.parse_format)
    input_file = args.input_file
    output_dir = os.path.realpath(args.output_dir)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    print("Dividing LLVM configuration input file: " + str(input_file))
    file_map = iomanager.divide_llvm_input(input_file)
    for file_name in file_map:
        basename = os.path.basename(file_name) + iomanager.get_file_extension()
        output_path = os.path.join(output_dir, basename)
        iomanager.output_to_file(output_path, file_map[file_name])
    print("The divided files have been generated under: " + output_dir)
    sys.exit(0)


def merge_main(args):
    """
    main program for merge command
    """
    iomanager = create_io_manager(args.parse_format)
    if args.input_file:
        input_files = args.input_file
        if args.output:
            output_file = args.output
        else:
            output_file = "merged_input" + iomanager.get_file_extension()
        print("Merging LLVM configuration input files: " + str(input_files))
        content = iomanager.parse_llvm_inputs(input_files)
        iomanager.output_to_file(output_file, content)
        print("The merged file has been generated: " + output_file)
        sys.exit(0)


def parse_main(args):
    """
    main program for parse command
    """
    iomanager = create_io_manager(args.parse_format)
    # if the search config file is not specified,
    # then use the default search space
    if not args.search_config_file:
        dir_name = os.path.dirname(__file__)
        args.search_config_file = os.path.join(
            dir_name,
            'search_space_config/default_search_space' +
            iomanager.get_file_extension())
    if args.opp_file:
        input_files = args.opp_file
        if args.output:
            output_file = args.output
        else:
            output_file = "search_space" + iomanager.get_file_extension()

        # if the hot function file is specified,
        # we need to parse it to get hot functions and append them into
        # func_name_filter list
        if (args.hot_func_file):
            hot_function_list = utils.parse_hot_function(
                args.hot_func_file, args.hot_func_number)
            args.func_name_filter = list(
                set(hot_function_list).union(set(args.func_name_filter)))

        print("Generating search space from " + str(input_files))
        iomanager.generate_search_space_file(input_files, output_file,
                                             args.search_config_file,
                                             args.name_filter,
                                             args.func_name_filter,
                                             args.file_name_filter,
                                             args.type_filter)
        print("The search space has been generated: " + output_file)
        sys.exit(0)


def run_main(args):
    """
    main program for run command
    """
    # init common options
    tuner, config = _parse_common_options(args)
    # compilation settings
    compile_section = config["Compiling Setting"]
    llvm_config_file = os.path.expanduser(compile_section["LLVMInputFile"])
    compile_dir = os.path.expanduser(compile_section["CompileDir"])
    compile_cmd = compile_section["CompileCommand"]

    opentuner.init_logging()

    tuner.main(args, compile_dir=compile_dir, program_name=args.config_file,
               llvm_config_file=llvm_config_file,
               fixed_llvm_config_files=args.add_llvm_inputs,
               enable_final_compile=args.enable_final_compile,
               search_space=args.search_space,
               run_dir=compile_section["RunDir"],
               run_cmd=compile_section["RunCommand"], compile_cmd=compile_cmd)


def auto_run_main(args):
    """
    main program for auto_run command
    """
    iomanager = create_io_manager(args.parse_format)
    is_first_stage = True
    # if the search config file is not specified,
    # then use the default search space
    if not args.search_config_file:
        dir_name = os.path.dirname(__file__)
        args.search_config_file = os.path.join(
            dir_name,
            'search_space_config/default_search_space' +
            iomanager.get_file_extension())
    # init common options
    tuner, config = _parse_common_options(args)

    # compilation settings
    compile_section = config["Compiling Setting"]
    llvm_config_file = os.path.expanduser(compile_section["LLVMInputFile"])
    compile_dir = os.path.expanduser(compile_section["CompileDir"])
    compile_cmd = compile_section["CompileCommand"]
    run_cmd = compile_section["RunCommand"]
    run_dir = compile_section["RunDir"]

    # auto-run additional settings
    opp_compile_cmd = compile_section["OppCompileCommand"]
    opp_dir = os.path.expanduser(compile_section["OppDir"])

    opentuner.init_logging()

    # clean llvm input file if there is existing one already
    try:
        os.remove(llvm_config_file)
    except OSError:
        pass

    # remove duplicates elements
    stages = list(OrderedDict.fromkeys(args.stage_order))

    # phases
    stages_info_str = ", ".join(stages)

    print("Running tuning with the stage order: {:s}".format(stages_info_str))

    for index, phase in enumerate(stages):
        if is_first_stage:
            fixed_llvm_config_files = args.add_llvm_inputs
            # create a dummy llvm config file for the first stage
            # to avoid the compiler's file-not-found error.
            iomanager.create_dummy_llvm_input(llvm_config_file)
        else:
            fixed_llvm_config_files = [llvm_config_file]

        print("=== Starting stage {:d}: {:s} level tuning ==="
              .format(index + 1, phase))
        search_space_tree = _generate_search_space(args, compile_dir,
                                                   iomanager, opp_compile_cmd,
                                                   opp_dir, phase)
        if search_space_tree is None:
            break
        try:
            tuner.main(args, compile_dir=compile_dir,
                       llvm_config_file=llvm_config_file,
                       enable_final_compile=True,
                       fixed_llvm_config_files=fixed_llvm_config_files,
                       search_space=search_space_tree,
                       run_dir=run_dir,
                       run_cmd=run_cmd, compile_cmd=compile_cmd,
                       stage=phase)
            is_first_stage = False
        except EmptySearchSpaceError:
            print('Empty search space, stop the current stage')


def _generate_search_space(args, compile_dir, iomanager, opp_compile_cmd,
                           opp_dir, phase):
    # before generating search space
    # clean the opp dir in case it is not empty
    _clean_opp(opp_dir)
    result = opentuner.MeasurementInterface(args).call_program(
        cmd=opp_compile_cmd, cwd=compile_dir)
    if result['returncode'] != 0:
        print("Failed to generate tuning opportunities, the error was:")
        print(result['stderr'])
        return None
    # generate search space based opp files
    opp_files = glob.glob(os.path.join(opp_dir, "*"))
    # if the hot function file is specified, we need to parse it to
    # get hot functions and append them into func_name_filter list
    if (args.hot_func_file):
        hot_function_list = utils.parse_hot_function(
            args.hot_func_file, args.hot_func_number)
        args.func_name_filter = list(
            set(hot_function_list).union(set(args.func_name_filter)))
    search_space_tree = iomanager.generate_search_space(
        opp_files,
        args.search_config_file,
        type_filter=[phase],
        func_name_filter=args.func_name_filter,
        file_name_filter=args.file_name_filter)
    return search_space_tree


def main():
    args = get_args()
    try:
        # if the sub-command merge is called
        if args.command == "merge":
            merge_main(args)
        if args.command == "divide":
            divide_main(args)
        # if the sub-command parse is called
        if args.command == "parse":
            parse_main(args)
        # if the sub-command run is called
        elif args.command == "run":
            try:
                run_main(args)
            except EmptySearchSpaceError:
                print('Empty search space, stop tuning')

        # if the sub-command auto_run is called
        else:
            auto_run_main(args)

    except ConfigParserError as error:
        print('Failed to parse your configuration file: ' + args.config_file)
        print(error)
        exit(1)

    except (OSError, IOError) as error:
        print('Failed to execute command "' + args.command + '". ')
        print(error)
        exit(1)

    except Exception as error:
        print('Failed to execute command "' + args.command + '". ')
        raise
